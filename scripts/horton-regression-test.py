#!/usr/bin/env python
# -*- coding: utf-8 -*-
# HORTON: Helpful Open-source Research TOol for N-fermion systems.
# Copyright (C) 2011-2019 The HORTON Development Team
#
# This file is part of HORTON.
#
# HORTON is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# HORTON is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>
#
# --
"""Rrun and generate regression tests."""


import argparse
import contextlib
import numbers
import os
import io
import sys
import textwrap

import numpy as np


from horton.test.common import numpy_seed
from horton.log import log


default_atol = 1e-5
default_rtol = 1e-7
comment_regtest = '# CODE BELOW IS FOR horton-regression-test.py ONLY. ' \
                  'IT IS NOT PART OF THE EXAMPLE.\n'
comment_auto = '# BEGIN AUTOGENERATED CODE. DO NOT CHANGE MANUALLY.\n'


template_unit_test = '''
# When using input or output files
@attr('rt')
def test_example_{example_name}():
    required = [context.get_fn('{example_path}')]
    expected = []  # TODO: add expected output filenames.
    check_script_in_tmp('horton-regression-test.py ./{example_basename}',
                        required, expected)

# Otherwise
@attr('rt')
def test_example_{example_name}():
    check_script('horton-regression-test.py ./{example_basename}',
                 context.get_fn('{example_dirname}'))
'''

epilog = '''\
One can test an example for regressions as follows:

    %(prog)s /data/examples/some/example.py

At the end of the example script, at least the following must be defined:

    {}
    rt_results = {{ ... }}

where rt_results must contain the results from the script to be verified. The keys should
be straightforward names. One may also add (with corresponding keys):
* rt_atols: the allowed maximum absolute deviation from the reference result.
  The default absolute threshold is {}.
* rt_rtols: the allowed maximum absolute deviation from the reference result.
  The default relative threshold is {}.
* rt_references: expected results, as obtained elsewhere (not with HORTON).
  Provide provenance info in the comments.
After running the regression test script in update mode, the "previous" results are added:

    {}
    rt_previous = {{ ... }}

The "previous" values can be updated or generated with:

    %(prog)s -u /data/examples/some/example.py

This will run the example and update the "previous" values that differ from the old ones
by more than the thresholds. It also prints unit test source code that can be included in
HORTON.

Known limitations:
1) Regression tests must be stored in ${{HORTONDATA}}/examples.
2) All of the results to be verified must by numpy compatible.
3) When the example script is moved/renamed, corresponding unit test code must be updated.
4) Previous results are printed into the example, so avoid large arrays.
'''.format(comment_regtest[:-1], default_atol, default_rtol, comment_auto[:-1])


class RegressionTestError(Exception):
    """Raised when an example script cannot be used as a regression test."""

    pass


@contextlib.contextmanager
def capture_io():
    """Context manager to capture standard output and error temporarily."""
    old_stdout = sys.stdout
    old_stderr = sys.stderr
    sys.stdout = io.StringIO()
    sys.stderr = io.StringIO()
    try:
        yield sys.stdout, sys.stderr
    finally:
        sys.stdout = old_stdout
        sys.stderr = old_stderr


def main():
    """Main program."""
    # Get command-line args
    example_paths, do_update, do_force, do_verbose = parse_args()

    # Silence the logger
    if not do_verbose:
        log.set_level(log.silent)

    # Exit status becomes 1 when some test results have changed beyond the thresholds, or
    # when previous or reference values are missing.
    exit_status = 0

    # Run all examples.
    for example_path in example_paths:
        print(example_path)

        # Sanity checks
        if not example_path.endswith(".py"):
            raise RegressionTestError('Example path should end with ".py": {}.'
                                      .format(example_path))
        with open(example_path) as f:
            example_lines = f.readlines()
            try:
                example_lines.index(comment_regtest)
            except ValueError:
                raise RegressionTestError('Missing regression-testing comment in example {}.'
                                          .format(example_path))

        # Run example and collect results.
        example_globals = {}
        with numpy_seed():
            print('   First random number:', np.random.rand())
        with open(example_path) as fh, numpy_seed():
            exec(fh, example_globals)  # pylint: disable=exec-used

        # Check that rt_results is defined in the example.
        if 'rt_results' not in example_globals:
            raise RegressionTestError('No rt_results defined in example {}.'
                                      .format(example_path))

        # Extract relevant variables from example.
        rt_results = example_globals['rt_results']
        rt_atols = example_globals.get('rt_atols', {})
        rt_rtols = example_globals.get('rt_rtols', {})
        rt_references = example_globals.get('rt_references', {})
        rt_previous = example_globals.get('rt_previous', {})
        known_keys = ['rt_results', 'rt_atols', 'rt_rtols', 'rt_references', 'rt_previous']
        for key in example_globals:
            if key.startswith('rt_') and key not in known_keys:
                print('Unrecognized variable starting with rt_: {}.' % key)

        # Compare results with expected or previous values, if previous values are present.
        rt_status = {}
        for key, result in rt_results.items():
            target = rt_references.get(key, rt_previous.get(key))
            if target is None:
                rt_status[key] = 'PREVIOUS OR REFERENCE MISSING'
            else:
                atol = rt_atols.get(key, default_atol)
                rtol = rt_rtols.get(key, default_rtol)
                if not isinstance(result, target.__class__):
                    rt_status[key] = 'WRONG TYPE'
                elif isinstance(result, np.ndarray) and (result.shape != target.shape):
                    rt_status[key] = 'WRONG SHAPE'
                elif np.allclose(result, target, atol=atol, rtol=rtol):
                    rt_status[key] = 'OK'
                else:
                    rt_status[key] = 'BOUNDS EXCEEDED'

        if do_update:
            update_example(example_path, example_lines, rt_previous, rt_results,
                           rt_status, do_force)
        else:
            exit_status |= report_regressions(rt_results, rt_atols, rt_rtols, rt_references,
                                              rt_previous, rt_status)

    # Stop with proper exit code.
    sys.exit(exit_status)


def parse_args():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description='Run or update regression tests.',
                                     epilog=epilog,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('example_paths', type=str, metavar='example', nargs='+',
                        help='Example scripts to run or update.')
    parser.add_argument('-u', '--update', default=False, action='store_true',
                        help='Update previous results in the regression test.')
    parser.add_argument('-f', '--force', default=False, action='store_true',
                        help='When in update mode (without -t), the default behavior is '
                             'to update the "previous" results only when they deviate '
                             'from the old "previous" results. This option forces all '
                             '"previous" results to be updated.')
    parser.add_argument('-v', '--verbose', default=False, action='store_true',
                        help='Do not silence the HORTON log.')
    args = parser.parse_args()
    return args.example_paths, args.update, args.force, args.verbose


def update_example(example_path, example_lines, rt_previous, rt_results, rt_status, do_force):
    """Rewrite the last few lines of the example with updated "previous" results."""
    # Additional sanity check
    if not example_path.startswith('data/examples/'):
        raise RegressionTestError('Example path should start with \'data/examples/\': {}.'
                                  .format(example_path))
    # Update previous values with current results, only when they changed or when
    # the force option is used.
    rt_new_previous = rt_previous.copy()
    changed = False
    for key, status in rt_status.items():
        if status != 'OK' or do_force:
            print('   Updating "{}"'.format(key))
            rt_new_previous[key] = rt_results[key]
            changed = True
        else:
            print('   Not updating "{}"'.format(key))

    if changed:
        print('   Rewriting example code.')
        # Load the example code.
        with open(example_path) as f:
            example_lines = f.readlines()

        # Search for the autogenerated previous results and strip them.
        try:
            index_auto = example_lines.index(comment_auto)
        except ValueError:
            index_auto = None
        if index_auto is not None:
            example_lines = example_lines[:index_auto]

        # Add new previous results
        example_lines.append(comment_auto)
        if any(isinstance(x, np.ndarray) for x in rt_new_previous.values()) and \
           not any('import numpy as np' in line for line in example_lines):
            example_lines.append('import numpy as np  # pylint: disable=wrong-import-position\n')
        example_lines.append('rt_previous = {\n')
        for key, new_previous in sorted(rt_new_previous.items()):
            representation = format_value(new_previous, key, example_path)
            example_lines.append('    \'{}\': {},\n'.format(key, representation))
        example_lines.append('}\n')

        # Write the updated code.
        with open(example_path, 'w') as f:
            f.writelines(example_lines)

    # Write basic unit test code to screen.
    print(template_unit_test.format(
        example_name=example_path[14:-3].replace('/', '_'),
        example_path=example_path[5:],
        example_basename=os.path.basename(example_path[5:]),
        example_dirname=os.path.dirname(example_path[5:]),
    ))


def format_value(value, key, example_path):
    """Format a previous value in full precision."""
    if isinstance(value, np.ndarray):
        # Multidimensional arrays are written as raveled vectors and are later reshaped
        # properly. This facilitates code formatting and results in more compact code.
        head = 'np.array(['
        data = ', '.join(repr(v) for v in value.flat)
        tail = '])'
        if len(value.shape) > 1:
            tail += '.reshape{}'.format(value.shape)
        if len(head) + len(data) + len(tail) <= 82 - len(key):
            result = head + data + tail
        else:
            # Wrap array over multiple lines, assuming key is not excessively long.
            # The result must be PEP8 compatible.
            lines = textwrap.wrap(data, 90, initial_indent=' '*8, subsequent_indent=' '*8)
            lines = [head] + lines + ['    ' + tail]
            result = '\n'.join(lines)
    elif isinstance(value, numbers.Number):
        result = repr(value)
    else:
        raise RegressionTestError('Cannot handle datatype of {} in "{}"'
                                  .format(key, example_path))
    return result


def report_regressions(rt_results, rt_atols, rt_rtols, rt_references, rt_previous, rt_status):
    """Report regressions.

    An update to the exit status is returned. Absence of a previous value is also an error.
    """
    exit_status = 0
    for key, status in rt_status.items():
        print('   Status "{}": {}'.format(key, status))
        if status == 'BOUNDS EXCEEDED':
            target = rt_references.get(key, rt_previous.get(key))
            result = rt_results.get(key)
            atol = rt_atols.get(key, default_atol)
            rtol = rt_rtols.get(key, default_rtol)
            abserr = abs(target - result)
            if isinstance(abserr, np.ndarray):
                maxabserr = abserr.max()
            else:
                maxabserr = abserr
            print('      Previous:       {}'.format(rt_previous.get(key)))
            print('      Reference:      {}'.format(rt_references.get(key)))
            print('      Result:         {}'.format(result))
            print('      Abs. Threshold: {}'.format(atol))
            print('      Rel. Threshold: {}'.format(rtol))
            print('      Max.Abs.Err.:   {}'.format(maxabserr))
        if status != 'OK':
            exit_status = 1
    return exit_status


if __name__ == '__main__':
    main()
